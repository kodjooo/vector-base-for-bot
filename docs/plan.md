Этап 1. Архитектурное проектирование и инфраструктурная подготовка — выполнено
- Зафиксировать целевой состав модулей и потоки данных между ними в `docs/architecture.md`, указать взаимодействие Google Docs → Embeddings → Векторная БД → GPT Assistant → интерфейсы.
- Определить используемую векторную базу (ChromaDB по умолчанию) и описать схему развёртывания сервисов в Docker (`app`, `chroma`, вспомогательные volume/сети).
- Согласовать структуру проекта: директории для сервисных модулей (`app/google_docs.py`, `app/chroma_manager.py`, `app/assistants.py`, `app/sync_docs.py`), вспомогательных пакетов и каталога `tests`.
- Провести ревизию `Dockerfile` и подготовить черновик `docker-compose.yml`, обеспечивающий локальный запуск приложения и векторной базы.

Этап 2. Управление конфигурацией и переменными окружения — выполнено
- Реализовать модуль `app/config.py`, централизованно читающий настройки (Pydantic Settings или аналог) и предоставляющий доступ к ключам API, параметрам БД, идентификаторам документов.
- Описать полный перечень переменных в `.env.example`, заполнить актуальные значения в `.env`, добавить проверки отсутствующих значений при старте приложения.
- Обеспечить безопасную работу с Google Service Account: чтение ключей из файла/JSON-переменной, обработка ошибок.
- Добавить модульные тесты для загрузки конфигурации и валидации обязательных полей.

Этап 3. Интеграция с Google Docs API — выполнено
- Реализовать `app/google_docs.py` для получения содержимого документов и даты последнего изменения (сервисный аккаунт, пагинация, преобразование структуры в плоский текст).
- Добавить механизм кеширования метаданных и ограничение по частоте запросов (backoff/квоты) с конфигурируемыми параметрами.
- Обновить `docs/architecture.md` разделом о взаимодействии с Google API и хранилищем метаданных (`meta/`).
- Покрыть модуль тестами с моками Google API, проверяющими парсинг текста и обработку ошибок сети.

Этап 4. Управление векторной базой и генерация эмбеддингов — выполнено
- Реализовать `app/chroma_manager.py` с клиентом к ChromaDB/Qdrant (инициализация коллекций, добавление, удаление, поиск документов).
- Имплементировать утилиты разбиения текста на чанки и получения эмбеддингов через OpenAI Embeddings API, предусмотреть конфигурируемые размеры чанков и перекрытие.
- Добавить обработку ошибок и повторов при работе с API, вести структурированные логи.
- Написать модульные тесты для логики чанкинга и обновления записей в коллекции (с моками API).

Этап 5. Сервис синхронизации документов — выполнено
- Создать `app/sync_docs.py`, orchestrator сканирования списка DOC_IDS: сравнение `modifiedTime`, удаление устаревших embeddings, обновление и логирование результата.
- Хранить состояние синхронизации в `meta/` (timestamp, версия эмбеддингов), предусмотреть консольный интерфейс (`python -m app.sync_docs`) и возвращаемые статусы.
- Включить задачу синхронизации в docker-compose (отдельный сервис/команда) и описать порядок запуска в `docs/architecture.md`.
- Покрыть критический поток интеграционными тестами (pytest, временная директория с фиктивными данными).

Этап 6. Интеграция с OpenAI Assistants API — выполнено
- Реализовать `app/assistants.py`, отвечающий за создание/получение thread_id, отправку сообщений, формирование подсказки с найденными контекстами и возврат ответа.
- Добавить сервис поиска по коллекции (поиск N релевантных чанков, формирование prompt) и механизм обработки ошибок API/таймаутов.
- Согласовать формат хранения thread_id для пользователей (на уровне бота или отдельного KV-хранилища) и задокументировать в архитектуре.
- Написать тесты с моками OpenAI, проверяющие построение запроса и обработку типовых ошибок.

Этап 7. Пользовательский интерфейс (Telegram Bot)
- Реализовать бота (aiogram/ python-telegram-bot) с поддержкой авторизации, команды `/start`, обработкой текстовых запросов, привязкой thread_id к пользователю.
- Интегрировать бота с сервисом ассистента и поиском по базе, добавить базовую обработку ошибок/тайм-аутов и уведомления пользователю.
- Обновить docker-compose (сервис бота), описать требования к вебхуку/long polling и обновить `.env` переменными для Telegram.
- Добавить компонентные тесты/юнит-тесты для хэндлеров (с использованием моков).

Этап 8. Планировщик обновлений и эксплуатационные задачи
- Внедрить планировщик (APScheduler внутри приложения или отдельный cron-контейнер) для регулярного запуска `sync_docs`, конфигурируемый через окружение.
- Настроить health-check endpoints/скрипты для ключевых сервисов и логирование (структурированные логи, уровни).
- Подготовить инструкции по развёртыванию и эксплуатации в `README.md` (минимально, только важные шаги согласно правилам) и дополнить `docs/architecture.md` эксплуатационным разделом.
- Сформировать финальный комплект автотестов (`tests/`), настроить GitHub Actions/аналог для прогонки тестов и линтеров, задокументировать команды запуска.
