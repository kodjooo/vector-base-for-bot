Архитектурное видение
- Система строится вокруг потока Google Docs → генерация эмбеддингов → самохостинговая ChromaDB → OpenAI Assistants → пользовательский интерфейс Telegram.
- Все серверные компоненты разворачиваются в Docker; orchestratorом выступает `docker-compose` с сервисами `app` (основное приложение) и `chroma` (векторная база).

Основные компоненты
- `GoogleDocsService` (`app/google_docs.py`) — авторизованный клиент Google Docs API и Google Drive API; получает текст документа, дату изменения, преобразует структуру в плоский текст, применяет троттлинг и кеш контролей.
- `EmbeddingService` (`app/embeddings.py`) — обёртка над OpenAI Embeddings API; разбивает текст на чанки, добавляет метаданные и возвращает эмбеддинги.
- `VectorStoreGateway` (`app/chroma_manager.py`) — клиент ChromaDB: инициализация коллекций, добавление/удаление чанков, поиск релевантных документов.
- `SyncOrchestrator` (`app/sync_docs.py`) — проверяет изменения в списке DOC_IDS, обновляет эмбеддинги, ведёт состояние в `meta/`.
- `AssistantGateway` (`app/assistants.py`) — взаимодействие с OpenAI Assistants API, формирование подсказок, работа с thread_id.
- `TelegramBot` (`app/bot.py`) — интерфейс для пользователей (aiogram), маршрутизация команд и обращение к ассистенту.
- `Scheduler` (`app/scheduler.py` или конфигурация APScheduler внутри приложения) — периодический запуск синхронизации.
- `Config` (`app/config.py`) — единая точка чтения переменных окружения, файлов настроек и путей.
- Тесты (`tests/`) — модульные, компонентные и интеграционные сценарии для ключевых подсистем.

Поток данных
1. Планировщик или оператор запускает `SyncOrchestrator`.
2. Оркестратор читает список DOC_IDS, по каждому документу запрашивает `modifiedTime` через Google Drive API.
3. Для изменённых документов `GoogleDocsService` извлекает текст, нормализует его и передаёт в `EmbeddingService`.
4. `EmbeddingService` генерирует чанки и эмбеддинги, `VectorStoreGateway` заменяет старые данные в коллекции ChromaDB.
5. Пользователь отправляет запрос боту; `TelegramBot` получает или создаёт `thread_id`, делегирует запрос в `AssistantGateway`.
6. `AssistantGateway` формирует запрос к поиску векторной базы через `VectorStoreGateway`, добавляет релевантные фрагменты в подсказку и вызывает OpenAI Assistants API.
7. Ответ ассистента возвращается пользователю, при необходимости сохраняется история в рамках `thread_id`.

Интеграция с Google API
- `GoogleDocsService` инициализирует клиенты Docs/Drive через сервисный аккаунт, обеспечивает минимальный интервал между запросами (`GOOGLE_REQUEST_INTERVAL_SECONDS`) и экспоненциальные повторы (`GOOGLE_MAX_RETRIES`, `GOOGLE_RETRY_INITIAL_DELAY`) при `HttpError`.
- Метаданные документов (`modifiedTime`, отметка обновления) сохраняются в `meta/<doc_id>.json` и используются для сравнения с текущими данными Drive перед запуском пересборки эмбеддингов.
- Метод `fetch_document` возвращает снапшот текста и метаданных; синхронизатор обновляет кеш через `persist_metadata` после успешной обработки.

Векторная база и эмбеддинги
- `EmbeddingService` (`app/embeddings.py`) разбивает текст на чанки (`chunk_text`) с перекрытием, управляемым параметрами `EMBEDDING_CHUNK_SIZE` и `EMBEDDING_CHUNK_OVERLAP`, и вызывает OpenAI Embeddings API с повторными попытками.
- `VectorStoreGateway` (`app/chroma_manager.py`) использует `chromadb.HttpClient` для доступа к коллекции (по умолчанию `knowledge`), удаляет устаревшие записи документа и добавляет новые чанки с метаданными.
- Поиск релевантных фрагментов выполняется через метод `query`, возвращающий структурированный ответ ChromaDB; логи ведутся на каждом этапе (удаление, добавление, поиск).

Ассистент OpenAI
- `AssistantService` (`app/assistants.py`) отвечает за поиск контекста перед обращением к OpenAI Assistants API: запрос эмбеддингов пользовательского сообщения, `VectorStoreGateway.query` с лимитом `ASSISTANT_SEARCH_TOP_K`, формирование подсказки и отправку сообщения через `client.beta.threads`.
- Ответы оборачиваются в `AssistantResponse` (thread_id, текст ответа, использованные чанки); сервис умеет создавать thread_id при первом обращении и сохранять его через `ThreadStore`.
- `InMemoryThreadStore` реализует базовое хранение связок пользователь → thread_id; для продакшена допускается замена на внешний KV (Redis/Postgres). Логика декораторно отделена интерфейсом `ThreadStore`.
- Ошибки/отсутствие контекста ведут к отправке чистого сообщения без префикса, а отсутствие ответа ассистента логируется и возвращает пустую строку.

Сервис синхронизации
- `SyncOrchestrator` (`app/sync_docs.py`) управляет пайплайном обновления: проверяет `needs_update`, при необходимости получает снапшот, разбивает текст на чанки, генерирует эмбеддинги и обновляет коллекцию Chroma.
- Для пустых документов выполняется удаление записей из хранилища, а результаты фиксируются в `meta/<doc_id>.json` через `GoogleDocsService.persist_metadata`.
- CLI `python -m app.sync_docs [--force]` позволяет запускать однократную синхронизацию; логирование конфигурируется через `LOG_LEVEL`.
- Возвращаемая структура `SyncResult` хранит статус (`skipped`, `updated`, `deleted`, `failed`) и используется для дальнейшего мониторинга/логирования.

Инфраструктура и развёртывание
- `app` — Python 3.12, зависимые библиотеки из `requirements.txt`, запуск `python -m app.main` (entrypoint будет расширен по мере реализации).
- `chroma` — контейнер `ghcr.io/chroma-core/chroma:latest`, открытый порт `8000`, постоянный том `./chroma_data:/chroma/chroma`.
- Локальные каталоги: `meta/` (кеш состояний синхронизации), `logs/` (при необходимости), `tests/` (автотесты). Каталоги создаются томами в docker-compose.
- Внутренняя сеть `app-net` обеспечивает безопасное взаимодействие между `app` и `chroma`; наружу пробрасывается только порт бота (при необходимости вебхука) и интерфейс Chroma для отладки.
- Все проверки выполняются внутри контейнера приложений (`docker compose run --rm app pytest`), поэтому локальные виртуальные окружения не требуются.
- В `docker-compose.yml` добавлен сервис `sync` (profile `sync`), который запускает однократную синхронизацию (`python -m app.sync_docs`) с доступом к `meta/` и зависимостью от `chroma`.

Структура проекта
- `app/__init__.py` — объявление пакета.
- `app/main.py` — точка входа; будет инициализировать конфигурацию, orchestrator и запуск бота/планировщика.
- `app/config.py` — чтение `.env`/`.env.example`, Pydantic Settings, валидация параметров API, параметров чанков, таймаутов.
- `app/google_docs.py` — рабочие функции и клиенты Google; вынести конвертацию документов и лимитирование.
- `app/chroma_manager.py` — инициализация клиентов Chroma/Qdrant, функции работы с коллекциями и поиском.
- `app/embeddings.py` — генерация эмбеддингов, разбиение текста, повторные попытки при ошибках API.
- `app/sync_docs.py` — CLI/entrypoint синхронизации, хранение метаданных, логирование результатов.
- `app/assistants.py` — взаимодействие с OpenAI Assistants API, комбинирование контекста и истории.
- `app/bot.py` — Telegram bot, хэндлеры, хранение связок пользователь → thread_id.
- `app/scheduler.py` — настройка APScheduler/cron-планировщик для запуска `sync_docs`.
- `tests/` — pytest-модули: конфигурация, Google Docs клиенты, управление векторной базой, синхронизация, ассистент, бот.

Конфигурация и секреты
- `app/config.py` использует Pydantic Settings: загрузка `.env`, переменных окружения и валидации (обязательный сервисный аккаунт, допустимые размеры чанков, корректный порт, положительный интервал).
- `.env` и `.env.example` синхронизированы; содержат ключи Google Service Account, токены OpenAI, Telegram Bot Token, параметры Chroma, расписания синхронизации, лимиты чанков.
- `GOOGLE_DOC_IDS` хранится в формате JSON-массива, что упрощает использование в настройках и тестах.
- `ASSISTANT_SEARCH_TOP_K` управляет количеством релевантных чанков, добавляемых в подсказку при запросе к ассистенту.
- Файл сервисного аккаунта Google предоставляется через путь в `GOOGLE_SERVICE_ACCOUNT_FILE` или JSON в `GOOGLE_SERVICE_ACCOUNT_INFO`; внутри контейнера монтируется как секрет.
- `get_settings()` кэшируется и доступен для сервисов приложения, `reload_settings()` используется тестами для сброса кэша перед валидациями.

Логирование и наблюдаемость
- Используется `logging` с JSON-форматом для сервисных слоёв; уровни конфигурируются через переменные окружения.
- Health-check: HTTP endpoint в приложении или команда `python -m app.sync_docs --health` для расписания.

Дальнейшие шаги
- Этап 7 сфокусирован на разработке Telegram-бота, использующего `AssistantService` и хранилище thread_id.
- Этап 8 завершит эксплуатационные задачи и планировщик.
